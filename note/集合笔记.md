# Java集合

### 集合概述

* Java集合类可以用于存储数量不等的多个对象，还可用于保存具有映射关系的关联数组
* <font color = red> Java集合可以分为```Collection``` 和 ```Map``` 两种体系</font>
  * ```Collection```接口：单列数据，定义了存取一组对象的方法的集合
    * ```List```：元素有序、可重复的集合
    * ```Set```： 元素无序、不可重复的集合
  *  ```Map```接口：双列数据，保存具有映射关系 ```key-value对```的集合
  * ```Collection```接口继承树：
  * <img src="C:\Users\86178\AppData\Roaming\Typora\typora-user-images\image-20210817095640934.png" alt="image-20210817095640934" style="zoom:80%;" />
    * ```Collection```接口是 ```List```、```Set```和 ```Queue```接口的父接口，该接口里面定义的方法既可用于操作 ```Set```合集，也可用于操作 ```List```、```Queue```集合。
    * JDK不提供此接口的任何直接实现，而是提供更具体的子接口（如：```List```、```Set```)实现。
    * Java5之前，Java集合会丢失容器中所有对象的数据类型，把所有对象都当成 ```Object```类型处理；从JDK5增加了<font color='red'>泛型</font>以后，Java集合可以记住容器中对象的数据类型。
  * ```Map```接口继承树：
    * <img src="C:\Users\86178\AppData\Roaming\Typora\typora-user-images\image-20210817100549344.png" alt="image-20210817100549344" style="zoom:80%;" />



* ```Iterator``` 对象称为迭代器(设计模式的一种)，主要用于遍历 ```Collection```集合中的元素。

* ```Iterator``` 仅用于遍历集合，```Iterator``` 本身并不提供承装对象的能力。如果需要创建```Iterator``` 对象，则必须有一个被迭代的集合。

* 集合对象每次调用```iterator()```方法都得到一个全新的迭代器对象，默认游标都在集合的第一个元素之前。 

* ![image-20210817111220425](C:\Users\86178\AppData\Roaming\Typora\typora-user-images\image-20210817111220425.png)

* ```Iterator``` 接口 remove() 方法

  * ```java
    Iterator iter = list.iterator();	//回到起点
    while(iter.hasNext()){
    	Object obj = iter.next();
        if(obj.equals("Tom")){
            iter.remove();
        }
    }
    ```

  * <font color='red'>注意：</font>

    * ```Iterator``` 可以删除集合的元素，但是是遍历过程中通过迭代器对象的remove方法，不是集合对象的remove方法。
    * <font color='red'>如果还未调用next() 或在上一次调用 next 方法之后已经调用了remove方法，再调用remove都会报 ```IllegalStateException```。</font>

  * 



### 2.Collection 子接口

#### 2.1List 接口

* 鉴于Java中数组用来存储数据有局限性，我们通常使用 List 替代数组

* List 集合类 有<font color='red'>元素有序、且可重复</font>，集合中每个元素都有其对应的顺序索引。

* JDK API 中 List 接口的实现类常用的有：<font color='red'>ArrayList, LinkedList 和 Vector</font>。、

* List 接口方法

  * List 除了从Collection合集继承的方法外，List集合里添加了一些根据索引来操作集合元素的方法。

  * ```java
    void add(int index, Object ele);	//在index位置插入ele元素
    boolean addAll(int index, Collection eles);	//从index位置开始将eles中的所有元素添加进来
    Object get(int index);	//获取指定index位置的元素
    int indexOf(Object obj);	//返回obj在集合中首次出现的位置
    int lastIndexOf(Object obj);	//返回obj在集合中最后一次出现的位置
    Object remove(int index);	//移除指定index位置的元素，并返回此元素
    Object set(int index, Object ele);	//设置指定 index 位置的元素为 ele
    List subList(int fromIndex, int toIndex);	//返回从 fromIndex 到 toIndex位置的子集合
    ```

##### 2.1.1 ArrayList

* ```ArrayList```是```List```接口的典型实现类、主要实现类
* 本质上，```ArrayList```是对象引用的一个“变长“数组
* ```ArrayList```在JDK7和JDK8的区别：
  * JDK7：```ArrayList```直接创建一个初识容量为10的数组
  * JDK8：```ArrayList```一开始创建一个长度为0的数组，当添加第一个元素时再创建一个初始容量为10的数组
* ```Arrays.asList(...)```方法返回的```List```集合，既不是```ArrayList```实例，也不是```Vector```实例。其返回值是一个固定长度的```List```集合。

##### 2.1.2 LinkedList

* 对于<font color='red'>频繁的插入和删除元素</font>的操作，建议使用```LinkedList```类，效率较高。```ArrayList```是数组，```LinkedList```是链表，可具体展开数组与链表的区别。

* 新增方法：

  * ```java
    void addFirst(Object obj);
    
    void addLast(Object obj);
    
    Object getFirst();
    
    Object getLast();
    
    Object removeFirst();
    
    Object removeLast();
    
    ```

* ```LinkedList```<font color='red'>:双向链表</font>，定义内部类 Node, 作为 LinkedList中保存数据的基本结构。Node除了保存数据，还定义了两个变量：

  * ```prev``` 变量记录前一个元素的位置

  * ```next``` 变量记录下一个元素的位置

  * ```java
    private static class Node<E> {
        E item;
        Node<E> prev;
        Node<E> next;
        
        Node(Node<E> prev, E element, Node<E> next){
            this.item = element;
            this.prev = prev;
            this.next = next;
        }
    }
    ```

  * <img src="C:\Users\86178\AppData\Roaming\Typora\typora-user-images\image-20210817154257759.png" alt="image-20210817154257759" style="zoom:80%;" />



##### 2.1.3 Vector

* ```Vector```是一个古老的集合，JDK1.0 就有了。大多数操作与 ```ArrayList```相同，区别之处在于<font color='cornflowerblue'>```Vector```是线程安全的</font>

* 在各种 list 中，当插入、删除频繁时，使用 ```LinkedList```；```Vector```总是比```ArrayList```慢，<font color = red>所以尽量避免使用</font>。

* 新增方法：

  * ```java
    void addElement(Object obj);
    
    void insertElementAt(Object obj, int index);
    
    void setElementAt(Object obj, int index);
    
    void removeElement(Object obj);
    
    void removeAllElement();
    
    ```

  * 

```bash
 # 问题：
 #ArrayList、LinkedList 与 Vector 三者区别？
 
 答：首先，ArrayList的实现是数组，底层为动态数组；LinkedList 为 双向链表结构。所以对于随机获取和set 比较多的操作可选取ArrayList，
 	对于在指定位置插入、删除操作比较频繁的可以选取LinkedList；ArrayList和LinkedList均为线程不安全。
 	
 	ArrayList与Vector 都是数组结构，但Vector是线程安全的；ArrayList在JDK7时，创建时会初识一个容量为10的数组，JDK8以后创建时是
 	一个空的数组，当首次添加数据时，会初识一个容量为10的数组；ArrayList扩容为1.5倍，Vector扩容为2倍。
```

#### 2.2 Set 接口

概述：

* ```Set```接口是```Collection```的子接口，```Set```接口没有提供额外的方法
* ```Set```集合不允许包含相同的元素，如果试把两个相同的元素加入同一个```Set```集合中，则添加操作失败
* ```Set```判断两个对象是否相同不是使用 ```==```运算符，而是根据 ```equals()```方法

##### 2.2.1 HashSet

* ```HashSet```是```Set```接口的典型实现，大多数时候使用```Set```集合时都使用这个实现类

*  ```HashSet```按```Hash```算法来存储集合中的元素，因此具有很好的存取、查找、删除性能

* ```HashSet```具有以下特点：

  * 不能保证元素的排列顺序
  * ```HashSet```不是线程安全的
  * 集合元素可以是 ```null```

* ```HashSet```集合判断两个元素相等的标准：两个对象通过```hashCode()```方法比较相等，并且两个对象的```equals()```方法返回值月相等。

  * ```bash
    #这里涉及问题：关于 hashCode, equals,相关的？？
    ```

* 对于存放在 ```Set```容器中的对象，<font color = red>对应的类一定要重写 ```equals() 和 hashCode(Object obj)方法，以实现对象相等规则。即：“相等的对象必须具有相等的散列码”。```</font>

* 向```HashSet```中添加元素的过程：

  * 当向```HashSet```集合存入一个元素时，```HashSet```会调用```HashCode```计算哈希值，然后通过哈希结果找到```HashSet```在数组中对应的位置。<font color = blue>(这个散列函数会与底层数组的长度相计算得到在数组的下标，并且这种散列函数计算还尽可能保证能均匀存储元素，越是散列分布，该散列函数设计的越好)</font>。
  * 如果该位置有元素，进行```equals```比较，如果结果为true，则添加失败；如果结果为false，保存该元素，但该数组位置已经有元素了，则进行链式的添加。
  * 如果两个元素的```equals```相等，但他们的```HashCode```返回值不相等，```HashSet```将会把他们存储在不同的位置，但依然可以添加成功



#### HashMap

1.JDK7 与 JDK8 的源码分析



##### JDK7 与 JDK8的区别

1.JDK8中会将链表转为红黑树

2.新节点插入链表的顺序不相同(JDK7是插入头结点，JDK8因为要遍历链表把链表变为红黑树所以采用插入尾结点)

3.hash算法简化

4.resize的逻辑修改(JDK7会出现死循环，JDK8不会) （死锁场景： http://www.importnew.com/22011.html)

